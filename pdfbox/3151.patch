### Eclipse Workspace Patch 1.0
#P fontbox
Index: src/main/java/org/apache/fontbox/cmap/CodespaceRange.java
===================================================================
--- src/main/java/org/apache/fontbox/cmap/CodespaceRange.java	(revision 1718847)
+++ src/main/java/org/apache/fontbox/cmap/CodespaceRange.java	(working copy)
@@ -122,6 +122,31 @@
     }
 
     /**
+     * Returns true if the given code bytes match this codespace range.
+     */
+    public boolean isFullMatch(byte[] code, int codeLen)
+    {
+        // code must be the same length as the bounding codes
+        if (codeLen >= start.length && codeLen <= end.length)
+        {
+            // each of it bytes must lie between the corresponding bytes of the upper & lower bounds
+            for (int i = 0; i < codeLen; i++)
+            {
+                int startNum = start[i] & 0xff;
+                int endNum = end[i] & 0xff;
+                int codeNum = code[i] & 0xff;
+
+                if (codeNum > endNum || codeNum < startNum)
+                {
+                    return false;
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+
+    /**
      * Returns true if the given byte matches the byte at the given index of this codespace range.
      */
     public boolean isPartialMatch(byte b, int index)
Index: src/main/java/org/apache/fontbox/cmap/CMap.java
===================================================================
--- src/main/java/org/apache/fontbox/cmap/CMap.java	(revision 1718847)
+++ src/main/java/org/apache/fontbox/cmap/CMap.java	(working copy)
@@ -104,15 +104,16 @@
         in.mark(4);
 
         // mapping algorithm
-        List<Byte> bytes = new ArrayList<Byte>(4);
+        byte[] bytes = new byte[4];
         for (int i = 0; i < 4; i++)
         {
-            bytes.add((byte)in.read());
+            bytes[i] = (byte)in.read();
+            final int byteCount = i+1;
             for (CodespaceRange range : codespaceRanges)
             {
-                if (range.isFullMatch(bytes))
+                if (range.isFullMatch(bytes, byteCount))
                 {
-                    return toInt(bytes);
+                    return toInt(bytes, byteCount);
                 }
             }
         }
@@ -121,15 +122,16 @@
         in.reset();
 
         // modified mapping algorithm
-        bytes = new ArrayList<Byte>(4);
         for (int i = 0; i < 4; i++)
         {
-            bytes.add((byte)in.read());
+            final byte curByte = (byte)in.read(); 
+            bytes[i] = curByte;
+            final int byteCount = i + 1;
             CodespaceRange match = null;
             CodespaceRange shortest = null;
             for (CodespaceRange range : codespaceRanges)
             {
-                if (range.isPartialMatch(bytes.get(i), i))
+                if (range.isPartialMatch(curByte, i))
                 {
                     if (match == null)
                     {
@@ -156,9 +158,9 @@
             }
 
             // we're done when we have enough bytes for the matched range
-            if (match != null && match.getStart().length == bytes.size())
+            if (match != null && match.getStart().length == byteCount)
             {
-                return toInt(bytes);
+                return toInt(bytes, byteCount);
             }
         }
 
@@ -168,13 +170,13 @@
     /**
      * Returns an int given a List<Byte>
      */
-    private int toInt(List<Byte> data)
+    private int toInt(byte[] data, int dataLen)
     {
         int code = 0;
-        for (byte b : data)
+        for (int i = 0; i < dataLen; ++i)
         {
             code <<= 8;
-            code |= (b + 256) % 256;
+            code |= (data[i] + 256) % 256;
         }
         return code;
     }
